bee-creative.util - [cc-by] Sebastian Rostock
Dieses Werk ist unter einem Creative Commons Namensnennung 3.0 Deutschland Lizenzvertrag lizenziert. Um die Lizenz
anzusehen, gehen Sie bitte zu:  [ http://creativecommons.org/licenses/by/3.0/de/ ] oder schicken Sie einen Brief an:
[ Creative Commons, 171 Second Street, Suite 300, San Francisco, California 94105, USA. ]

Diese Bibliothek beinhaltet mehrere Hilfsklassen und Hilfsmethoden zur Realisirung funktionaler Operatoren auf Filtern, 
Iteratoren und Convertern im Zusammenhang mit anderen Schnittstellen.

_______________________________________________________________________________________________________________________

Beispiele 1: Filter, Iterable, Converter 

  In diesem Beispiel soll aus einer Menge benannter Objekte (NamedEntry) die Menge der Objekte ermittelt werden, deren
  Name mit einem gegebenen Präfix beginnt bzw. einem gegebenen Suffix endet.

  ---------------------------------------------------------------------------------------------------------------------

  * Eingabe
    - String - Präfix
    - String - Suffix
    - Iterable<NamedEntry> - Menge der benannten Objekte 

  ---------------------------------------------------------------------------------------------------------------------

  * Ausgabe
    - Iterable<NamedEntry> - Objekte mit dem Präfix oder Suffix im Namen

  ---------------------------------------------------------------------------------------------------------------------

  * Quelltext
  
    class NamedEntry {

      String name;

      // ...

    }

    void work(...) {
    
      // Eingabe
      final String prefix = ...
      final String suffix = ...
      Iterable<NamedEntry> namedEntris = ...

      // Converter
      Converter<NamedEntry, String> nameConverter = new Converter<NamedEntry, String>() {

        @Override
        public String convert(final NamedEntry input) {
          return input.name;
        }

      };
      
      // Filter
      Filter<String> prefixFilter = new Filter<String>() {

        @Override
        public boolean accept(final String input) {
          return input.startsWith(prefix);
        }

      };
      Filter<String> suffixFilter = new Filter<String>() {

        @Override
        public boolean accept(final String input) {
          return input.endsWith(suffix);
        }

      };
      Filter<NamedEntry> namedPrefixFilter = Filters.convertedFilter(nameConverter, prefixFilter);
      Filter<NamedEntry> namedSuffixFilter = Filters.convertedFilter(nameConverter, suffixFilter);
      Filter<NamedEntry> filter = Filters.disjunctionFilter(namedPrefixFilter, namedSuffixFilter);

      // Ausgabe
      Iterable<NamedEntry> filteredNamedEntris = Iterables.filteredIterable(filter, namedEntris);

    }

_______________________________________________________________________________________________________________________

Beispiele 2: Iterable, Converter, Conversion, Comparator

  In diesem Beispiel soll eine Menge komplexer Objekte (ComplexEntry) zur Anzeige in einer sortierten Auswahlliste 
  aufbereitet werden. Die für die Anzeige benötigten Texte (String) werden hierbei mit Hilfe einer aufwändigen 
  Formatierungsmethode (ComplexFormatConverter) berechnet. Die Sortierung der Auswahlliste soll an Hand der 
  berechneten Texte erfolgen.
  
  ---------------------------------------------------------------------------------------------------------------------

  * Eingabe
    - Iterable<ComplexEntry> - Menge der komplexen Objekte 

  ---------------------------------------------------------------------------------------------------------------------

  * Ausgabe
    - List<String> - sortierte Liste der Texte zu den komplexen Objekte
    - List<ComplexEntry> - nach Text sortierte Liste der komplexen Objekte

  ---------------------------------------------------------------------------------------------------------------------

  * Quelltext
  
    class ComplexEntry {

      static Converter<ComplexEntry, String> ComplexFormatConverter = new Converter<ComplexEntry, String>() {

        @Override
        public String convert(final ComplexEntry input) {
          final StringBuilder builder = new StringBuilder();
          // ... aufwändige Formatierung
          return builder.toString();
        }

      };

      // ...

    }

    void work(...) {
    
      // Eingabe
      Iterable<ComplexEntry> complexEntries = ...
      
      // Ausgabe
      List<ComplexEntry> sortedComplexEntryList = new ArrayList<ComplexEntry>();
      List<String> sortedComplexFormatList = new ArrayList<String>();

      // Conversion
      List<Conversion<ComplexEntry, String>> conversionList = new ArrayList<Conversion<ComplexEntry, String>>();
      Converter<ComplexEntry, Conversion<ComplexEntry, String>> conversionConverter =
        Conversions.staticConversionConverter(ComplexEntry.ComplexFormatConverter);

      ConvertedIterable<ComplexEntry, Conversion<ComplexEntry, String>> conversionIterable =
        Iterables.convertedIterable(conversionConverter, complexEntries);

      Iterables.appendAll(conversionList, conversionIterable);
      
      // Conversion.Output
      Converter<Conversion<?, ? extends String>, String> conversionOutputConverter =
        Conversions.conversionOutputConverter();

      ConvertedComparator<Conversion<?, ? extends String>, String> conversionOutputComparator =
        Comparators.convertedComparator(conversionOutputConverter, Comparators.stringAlphanumericalComparator());

      Collections.sort(conversionList, conversionOutputComparator);

      ConvertedIterable<Conversion<ComplexEntry, String>, String> conversionOutputIterable =
        Iterables.convertedIterable(conversionOutputConverter, conversionList);

      Iterables.appendAll(sortedComplexFormatList, conversionOutputIterable);
      
      // Conversion.Input
      Converter<Conversion<? extends ComplexEntry, ?>, ComplexEntry> conversionInputConverter =
        Conversions.<ComplexEntry>conversionInputConverter();

      ConvertedIterable<Conversion<ComplexEntry, String>, ComplexEntry> conversionInputIterable =
        Iterables.convertedIterable(conversionInputConverter, conversionList);

      Iterables.appendAll(sortedComplexEntryList, conversionInputIterable);
      
    }
    
_______________________________________________________________________________________________________________________
 
TODO Beispiele 3: Comparable
  - Binäre Suche nach Bereichen in Liste

  public static class Range {
    int from; // Startposition der Range
    int size; // Größe/Länge der Range
    // ...
  }

  public Range find(final List<Range> ranges, final int position) {
    final int index = Comparables.binarySearch(ranges, new Comparable<Range>() {

      @Override
      public int compareTo(final Range o) {
        if(o.from > position) return 1; 
        if((o.from + o.size) <= position) return -1;
        return 0;
      }

    });
    if(index < 0) return null;
    return ranges.get(index);
  }

TODO Beispiele 4: Pointer, Builder 
  - Cache mit automatischem Builder

  public final class Helper {

    private static final Builder<Helper> BUILDER = Builders.synchronizedBuilder(
      Builders.cachedBuilder(Pointers.SOFT, new Builder<Helper>() {

        @Override
        public Helper build() {
          return new Helper();
        }

      }));

    public static Helper get() {
      return Helper.BUILDER.build();
    }

    Helper() {
      // ...
    }

  }


  public void work() {
    final Helper helper = Helper.get();
    // ...
  }
  